/*
 *  Copyright (c) 2023, Seqera Labs.
 *
 *  This Source Code Form is subject to the terms of the Mozilla Public
 *  License, v. 2.0. If a copy of the MPL was not distributed with this
 *  file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 *  This Source Code Form is "Incompatible With Secondary Licenses", as
 *  defined by the Mozilla Public License, v. 2.0.
 */

/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package io.seqera.wavelit;

import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.OffsetDateTime;
import java.util.Base64;

import io.seqera.wave.api.SubmitContainerTokenRequest;
import io.seqera.wave.api.SubmitContainerTokenResponse;
import io.seqera.wavelit.exception.IllegalCliArgumentException;
import io.seqera.wavelit.util.CliVersionProvider;
import picocli.CommandLine;
import static org.apache.commons.lang3.StringUtils.isEmpty;
import static picocli.CommandLine.Command;
import static picocli.CommandLine.Option;

/**
 * Wavelit entrypoint class
 */
@Command(name = "wavelit", description = "Wave command line tool", mixinStandardHelpOptions = true, versionProvider = CliVersionProvider.class)
public class App implements Runnable {

    @Option(names = {"-i", "--image"}, description = "Container image name to be provisioned")
    private String image;

    @Option(names = {"-c", "--containerfile"}, description = "Container file (i.e. Dockerfile) to be used to build the image")
    private String containerFile;

    @Option(names = {"--tower-token"}, description = "Tower service access token")
    private String towerToken;

    @Option(names = {"--tower-endpoint"}, description = "Tower service endpoint")
    private String towerEndpoint;

    private Long towerWorkspaceId;

    @Option(names = {"--build-repo"}, description = "The container repository where image build by Wave will stored")
    private String buildRepository;

    @Option(names = {"--cache-repo"}, description = "The container repository where image layer created by Wave will stored")
    private String cacheRepository;

    @Option(names = {"--wave-endpoint"}, description = "Wave service endpoint (default: ${DEFAULT-VALUE})")
    private String waveEndpoint = Client.DEFAULT_ENDPOINT;

    @Option(names = {"--freeze"}, description = "Request a container freeze")
    private boolean freeze;


    @Option(names = {"--await"}, description = "Await the container build to be available")
    private boolean await;

    public static void main(String[] args) {
        try {
            CommandLine.run(new App(), args);
        }
        catch (CommandLine.ExecutionException e) {
            Throwable err = e.getCause()!=null ? e.getCause() : e;
            System.err.println(err.getMessage());
            System.exit(1);
        }
        catch (Throwable e) {
            e.printStackTrace(System.err);
            System.exit(1);
        }
    }

    protected void defaultArgs() {
        if( isEmpty(towerEndpoint) && System.getenv().containsKey("TOWER_API_ENDPOINT") ) {
            towerEndpoint = System.getenv("TOWER_API_ENDPOINT");
        }
        if( isEmpty(towerToken) && System.getenv().containsKey("TOWER_ACCESS_TOKEN") ) {
            towerToken = System.getenv("TOWER_ACCESS_TOKEN");
        }
        if( towerWorkspaceId==null && System.getenv().containsKey("TOWER_WORKSPACE_ID") ) {
            towerWorkspaceId = Long.valueOf(System.getenv("TOWER_WORKSPACE_ID"));
        }
    }

    protected void validateArgs() {
        if( !isEmpty(image) && !isEmpty(containerFile) )
            throw new IllegalCliArgumentException("Argument --image and --containerfile conflict each other - Specify an image name or a container file for the container to be provisioned");

        if( isEmpty(image) && isEmpty(containerFile) )
            throw new IllegalCliArgumentException("Provide either a image name or a container file for the Wave container to be provisioned");

        if( freeze && isEmpty(buildRepository) )
            throw new IllegalCliArgumentException("Specify the build repository where the freeze container will be pushed by using the --build-repo option");

        if( isEmpty(towerToken) && !isEmpty(buildRepository) )
            throw new IllegalCliArgumentException("Specify the Tower access token required to authenticate the access to the build repository either by using the --tower-token option or the TOWER_ACCESS_TOKEN environment variable");
    }

    protected Client client() {
        return new Client().withEndpoint(waveEndpoint);
    }

    protected SubmitContainerTokenRequest createRequest() {
        return new SubmitContainerTokenRequest()
                .withContainerImage(image)
                .withContainerFile(encodeBase64(containerFile))
                .withTimestamp(OffsetDateTime.now())
                .withBuildRepository(buildRepository)
                .withCacheRepository(cacheRepository)
                .withTowerAccessToken(towerToken)
                .withTowerWorkspaceId(towerWorkspaceId)
                .withTowerEndpoint(towerEndpoint)
                .withFreezeMode(freeze)
                ;
    }

    @Override
    public void run() {
        // default Args
        defaultArgs();
        // validate the command line args
        validateArgs();
        // create the wave request
        SubmitContainerTokenRequest request = createRequest();
        // creat the client
        final Client client = client();
        // submit it
        SubmitContainerTokenResponse resp = client.submit(request);
        // await build to be completed
        if( await && !isEmpty(resp.buildId) )
            client.awaitImage(resp.targetImage);
        // print the wave container name
        System.out.println( freeze
                ? resp.containerImage
                : resp.targetImage );
    }

    private String encodeBase64(String value) {
        try {
            if( isEmpty(value) )
                return null;
            // check if it's a file path
            if( value.startsWith("/") || value.startsWith("./") ) {
                return Base64.getEncoder().encodeToString(Files.readAllBytes(Path.of(value)));
            }
            if( value.startsWith("file:/") || value.startsWith("http://") || value.startsWith("https://")) {
                return Base64.getEncoder().encodeToString(Files.readAllBytes(Path.of(new URI(value))));
            }
            // parse a plain dockerfile string
            return Base64.getEncoder().encodeToString(value.getBytes());
        }
        catch (URISyntaxException e) {
            throw new IllegalCliArgumentException("Invalid container file URI path - offending value: " + value, e);
        }
        catch (IOException e) {
            throw new IllegalCliArgumentException("Unable to read container file - reason: " + e.getMessage(), e);
        }
    }
}
