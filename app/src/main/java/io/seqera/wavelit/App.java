/*
 *  Copyright (c) 2023, Seqera Labs.
 *
 *  This Source Code Form is subject to the terms of the Mozilla Public
 *  License, v. 2.0. If a copy of the MPL was not distributed with this
 *  file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 *  This Source Code Form is "Incompatible With Secondary Licenses", as
 *  defined by the Mozilla Public License, v. 2.0.
 */

/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package io.seqera.wavelit;

import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.OffsetDateTime;
import java.util.Base64;

import io.seqera.wave.api.SubmitContainerTokenRequest;
import io.seqera.wave.api.SubmitContainerTokenResponse;
import io.seqera.wavelit.exception.IllegalCliArgumentException;
import io.seqera.wavelit.util.CliVersionProvider;
import picocli.CommandLine;
import static org.apache.commons.lang3.StringUtils.isEmpty;
import static picocli.CommandLine.Command;
import static picocli.CommandLine.Option;

/**
 * Wavelit entrypoint class
 */
@Command(name = "wavelit", description = "Wave command line tool", mixinStandardHelpOptions = true, versionProvider = CliVersionProvider.class)
public class App implements Runnable {

    @Option(names = {"-i", "--image"}, description = "Container image name to be provisioned")
    private String image;

    @Option(names = {"-c", "--containerfile"}, description = "Container file (i.e. Dockerfile) to be used to build the image")
    private String containerFile;

    private String towerToken;

    @Option(names = {"--tower-endpoint"}, description = "Tower service endpoint")
    private String towerEndpoint;

    private Long towerWorkspaceId;

    @Option(names = {"--build-repo"}, description = "The container repository where image build by Wave will stored")
    private String buildRepository;

    @Option(names = {"--cache-repo"}, description = "The container repository where image layer created by Wave will stored")
    private String cacheRepository;

    @Option(names = {"--wave-endpoint"}, description = "Wave service endpoint (default: ${DEFAULT-VALUE})")
    private String waveEndpoint = Client.DEFAULT_ENDPOINT;

    public static void main(String[] args) {
        try {
            CommandLine.run(new App(), args);
        }
        catch (CommandLine.ExecutionException e) {
            Throwable err = e.getCause()!=null ? e.getCause() : e;
            System.err.println(err.getMessage());
            System.exit(1);
        }
        catch (Throwable e) {
            e.printStackTrace(System.err);
            System.exit(1);
        }
    }

    protected void validateArgs() {
        if( !isEmpty(image) && !isEmpty(containerFile) )
            throw new IllegalCliArgumentException("Argument --image and --containerfile conflict each other - Specify an image name or a container file for the container to be provisioned");

        if( isEmpty(image) && isEmpty(containerFile) )
            throw new IllegalCliArgumentException("Provide either a image name or a container file for the Wave container to be provisioned");
    }

    protected Client client() {
        return new Client().withEndpoint(waveEndpoint);
    }

    protected SubmitContainerTokenRequest createRequest() {
        return new SubmitContainerTokenRequest()
                .withContainerImage(image)
                .withContainerFile(encodeBase64(containerFile))
                .withTimestamp(OffsetDateTime.now())
                .withBuildRepository(buildRepository)
                .withCacheRepository(cacheRepository)
                .withTowerAccessToken(towerToken)
                .withTowerWorkspaceId(towerWorkspaceId)
                .withTowerEndpoint(towerEndpoint)
                ;
    }

    @Override
    public void run() {
        // validate the command line args
        validateArgs();
        // create the wave request
        SubmitContainerTokenRequest request = createRequest();
        // submit it
        SubmitContainerTokenResponse resp = client().submit(request);
        // print the wave container name
        System.out.println(resp.targetImage);
    }

    private String encodeBase64(String value) {
        try {
            if( isEmpty(value) )
                return null;
            // check if it's a file path
            if( value.startsWith("/") || value.startsWith("./") ) {
                return Base64.getEncoder().encodeToString(Files.readAllBytes(Path.of(value)));
            }
            if( value.startsWith("file:/") || value.startsWith("http://") || value.startsWith("https://")) {
                return Base64.getEncoder().encodeToString(Files.readAllBytes(Path.of(new URI(value))));
            }
            // parse a plain dockerfile string
            return Base64.getEncoder().encodeToString(value.getBytes());
        }
        catch (URISyntaxException e) {
            throw new IllegalCliArgumentException("Invalid container file URI path - offending value: " + value, e);
        }
        catch (IOException e) {
            throw new IllegalCliArgumentException("Unable to read container file - reason: " + e.getMessage(), e);
        }
    }
}
